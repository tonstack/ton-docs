unit$_ = Unit;
true$_ = True;

bool_false$0 = Bool;
bool_true$1 = Bool;

bool_false$0 = BoolFalse;
bool_true$1 = BoolTrue;

nothing$0 {X:Type} = Maybe X;
just$1 {X:Type} value:X = Maybe X;

left$0 {X:Type} {Y:Type} value:X = Either X Y;
right$1 {X:Type} {Y:Type} value:Y = Either X Y;

pair$_ {X:Type} {Y:Type} first:X second:Y = Both X Y;

bit$_ (## 1) = Bit;

addr_none$00 = MsgAddressExt;
addr_extern$01 len:(## 9) external_address:(bits len) 
             = MsgAddressExt;
             
anycast_info$_ depth:(#<= 30) { depth >= 1 }
   rewrite_pfx:(bits depth) = Anycast;
   
addr_std$10 anycast:(Maybe Anycast) 
   workchain_id:int8 address:bits256  = MsgAddressInt;
addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9) 
   workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
   
_ _:MsgAddressInt = MsgAddress;
_ _:MsgAddressExt = MsgAddress;

var_uint$_ {n:#} len:(#< n) value:(uint (len * 8))
         = VarUInteger n;
var_int$_ {n:#} len:(#< n) value:(int (len * 8)) 
        = VarInteger n;
nanotons$_ amount:(VarUInteger 16) = TONs;  

extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32)) 
                 = ExtraCurrencyCollection;
                 
currencies$_ tons:TONs other:ExtraCurrencyCollection 
           = CurrencyCollection;
